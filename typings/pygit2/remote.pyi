"""
This type stub file was generated by pyright.
"""

class TransferProgress:
    """Progress downloading and indexing data during a fetch."""

    def __init__(self, tp) -> None: ...

class Remote:
    def __init__(self, repo, ptr) -> None:
        """The constructor is for internal use only."""
        ...
    def __del__(self): ...
    @property
    def name(self):  # -> None:
        """Name of the remote"""
        ...
    @property
    def url(self):  # -> None:
        """Url of the remote"""
        ...
    @property
    def push_url(self):  # -> None:
        """Push url of the remote"""
        ...
    def connect(self, callbacks=..., direction=..., proxy=...):  # -> None:
        """Connect to the remote.

        Parameters:

        proxy : None or True or str
            Proxy configuration. Can be one of:

            * `None` (the default) to disable proxy usage
            * `True` to enable automatic proxy detection
            * an url to a proxy (`http://proxy.example.org:3128/`)
        """
        ...
    def fetch(
        self, refspecs=..., message=..., callbacks=..., prune=..., proxy=...
    ) -> TransferProgress:
        """Perform a fetch against this remote. Returns a <TransferProgress>
        object.

        Parameters:

        prune : enum
            Either <GIT_FETCH_PRUNE_UNSPECIFIED>, <GIT_FETCH_PRUNE>, or
            <GIT_FETCH_NO_PRUNE>. The first uses the configuration from the
            repo, the second will remove any remote branch in the local
            repository that does not exist in the remote and the last will
            always keep the remote branches

        proxy : None or True or str
            Proxy configuration. Can be one of:

            * `None` (the default) to disable proxy usage
            * `True` to enable automatic proxy detection
            * an url to a proxy (`http://proxy.example.org:3128/`)
        """
        ...
    def ls_remotes(self, callbacks=..., proxy=...):  # -> list[Unknown]:
        """
        Return a list of dicts that maps to `git_remote_head` from a
        `ls_remotes` call.

        Parameters:

        callbacks : Passed to connect()

        proxy : Passed to connect()
        """
        ...
    def prune(self, callbacks=...):  # -> None:
        """Perform a prune against this remote."""
        ...
    @property
    def refspec_count(self):
        """Total number of refspecs in this remote"""
        ...
    def get_refspec(self, n):  # -> Refspec:
        """Return the <Refspec> object at the given position."""
        ...
    @property
    def fetch_refspecs(self):
        """Refspecs that will be used for fetching"""
        ...
    @property
    def push_refspecs(self):
        """Refspecs that will be used for pushing"""
        ...
    def push(self, specs, callbacks=..., proxy=...):  # -> None:
        """
        Push the given refspec to the remote. Raises ``GitError`` on protocol
        error or unpack failure.

        When the remote has a githook installed, that denies the reference this
        function will return successfully. Thus it is strongly recommended to
        install a callback, that implements
        :py:meth:`RemoteCallbacks.push_update_reference` and check the passed
        parameters for successfull operations.

        Parameters:

        specs : [str]
            Push refspecs to use.

        proxy : None or True or str
            Proxy configuration. Can be one of:

            * `None` (the default) to disable proxy usage
            * `True` to enable automatic proxy detection
            * an url to a proxy (`http://proxy.example.org:3128/`)
        """
        ...

class RemoteCollection:
    """Collection of configured remotes

    You can use this class to look up and manage the remotes configured
    in a repository.  You can access repositories using index
    access. E.g. to look up the "origin" remote, you can use

    >>> repo.remotes["origin"]
    """

    def __init__(self, repo) -> None: ...
    def __len__(self): ...
    def __iter__(self): ...
    def __getitem__(self, name) -> Remote: ...
    def names(self):  # -> Generator[Unknown | None, Any, None]:
        """An iterator over the names of the available remotes."""
        ...
    def create(self, name, url, fetch=...):  # -> Remote:
        """Create a new remote with the given name and url. Returns a <Remote>
        object.

        If 'fetch' is provided, this fetch refspec will be used instead of the
        default.
        """
        ...
    def create_anonymous(self, url):  # -> Remote:
        """Create a new anonymous (in-memory only) remote with the given URL.
        Returns a <Remote> object.
        """
        ...
    def rename(self, name, new_name):
        """Rename a remote in the configuration. The refspecs in standard
        format will be renamed.

        Returns a list of fetch refspecs (list of strings) which were not in
        the standard format and thus could not be remapped.
        """
        ...
    def delete(self, name):  # -> None:
        """Remove a remote from the configuration

        All remote-tracking branches and configuration settings for the remote will be removed.
        """
        ...
    def set_url(self, name, url):  # -> None:
        """Set the URL for a remote"""
        ...
    def set_push_url(self, name, url):  # -> None:
        """Set the push-URL for a remote"""
        ...
    def add_fetch(self, name, refspec):  # -> None:
        """Add a fetch refspec (str) to the remote"""
        ...
    def add_push(self, name, refspec):  # -> None:
        """Add a push refspec (str) to the remote"""
        ...
